# エキスパートPythonプログラミング読書会 第二期 02
* 日付：2011/12/13 (Wed)  19:00~
* イベントサイト：https://connpass.com/event/118/
* 第一期のログ：http://www.freia.jp/taka/docs/expertpython/reading/02.html
* 前回資料：

# リスト内包表記
* むっちゃ短く書けるし、わかりやすい
    * [i for i in range(10)]
    * リストで出てくる、早い
        * 早いのは処理が少ないから
    * [値 for文 その他絞りたい条件]
* あまり長く書きすぎると意味ない（わかりにくい）


* 遅くてもいいから分かりやすく書く

# enumerate
* 番号を付けることができる
* enumerate()

# import this
* Do it

# イテレータ
* イテレータプロトコル
    * __next__メソッド：コンテナの次の要素を示す
    * __iter__メソッド：イテレータそのものを返す
* 抽象クラス：型だけ用意してあって、それにあわせて実装していく。それが実装されていないとインスタンス生成が出来ない
    * プロトコルを守るための仕組み

# ジェネレータ
* イテレータ便利だけど、いちいちクラスを作るのはだるい
* 関数の表記で出来るようにしたのがジェネレータ
* つまり…
    * yieldがある→ジェネレータ
    * yieldがない→関数
# yield?
* ジェネレータにするためのキモがyield
* returnとは違う
    * 共存させると怒られる
* ジェネレーターはリセットできない
    * imagawa_yakata: @mactkg ジェネレータは次々に要素をちょっとずつ返させたいときに使うもんだから、クリアできると仮定すると全体が最初に与えられている前提と矛盾する。 [http://twitter.com/#!/imagawa_yakata/status/146549864736624640]

# 文と式
* Pythonでは文と式をしっかり区別する
    * 式→値を返す
    * 文→値を返さない

例：
    ex)
    for e in (r = range(10)):
                ^
    SyntaxError: invalid syntax

# ジェネレータ式
* リスト内表記の[]を()にするとジェネレータになる
* 逐次処理に便利

## xrangeの話
* rangeとxrangeが違い、確かxrangeはメモリを食わないって@salexkiddが言ってたのを思い出したが、どう違うのかググった
* xrangeはxrangeオブジェクトを返すらしい
* xrangeオブジェクトはいてれーたぶるなもの（イテレータの動き）
* ただPython3.0のrange自体がジェネレータになる→xrangeなくなる
* *xrangeは3.xへの移行のしやすさを考えると使う理由はあんまない*
* ｋｗｓｋ：http://d.hatena.ne.jp/fn7/20100525/1274830942
